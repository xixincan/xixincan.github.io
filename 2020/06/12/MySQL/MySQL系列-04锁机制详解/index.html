<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL系列--04锁机制详解 | 奚新灿的博客-Chronos</title><meta name="description" content="简介数据库锁设计的初衷是处理并发问题。当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁、页级锁和行锁四类。这些锁都属于悲观锁。 MySQL还有一个显著的特点就是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking"><meta name="keywords" content="MySQL,行锁,表锁,全局锁,页级锁,意向锁,间隙锁"><meta name="author" content="奚新灿,xixincan@163.com"><meta name="copyright" content="奚新灿"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="MySQL系列--04锁机制详解"><meta name="twitter:description" content="简介数据库锁设计的初衷是处理并发问题。当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁、页级锁和行锁四类。这些锁都属于悲观锁。 MySQL还有一个显著的特点就是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking"><meta name="twitter:image" content="https://i.loli.net/2020/06/07/oHqT26jk1xnbKJ9.png"><meta property="og:type" content="article"><meta property="og:title" content="MySQL系列--04锁机制详解"><meta property="og:url" content="https://github.com/xixincan/xixincan.github.io/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"><meta property="og:site_name" content="奚新灿的博客-Chronos"><meta property="og:description" content="简介数据库锁设计的初衷是处理并发问题。当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁、页级锁和行锁四类。这些锁都属于悲观锁。 MySQL还有一个显著的特点就是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking"><meta property="og:image" content="https://i.loli.net/2020/06/07/oHqT26jk1xnbKJ9.png"><meta property="article:published_time" content="2020-06-12T04:52:47.000Z"><meta property="article:modified_time" content="2021-06-11T20:02:26.112Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://github.com/xixincan/xixincan.github.io/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"><link rel="prev" title="MySQL系列--05索引详解" href="https://github.com/xixincan/xixincan.github.io/2020/06/16/MySQL/MySQL%E7%B3%BB%E5%88%97-05%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"><link rel="next" title="MySQL系列--03事务及隔离级别" href="https://github.com/xixincan/xixincan.github.io/2020/06/09/MySQL/MySQL%E7%B3%BB%E5%88%97-03%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xixincan.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: 奚新灿","link":"链接: ","source":"来源: 奚新灿的博客-Chronos","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: false,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/v.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#全局锁"><span class="toc-number">2.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表级锁"><span class="toc-number">3.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表锁"><span class="toc-number">3.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元数据锁"><span class="toc-number">3.2.</span> <span class="toc-text">元数据锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行锁"><span class="toc-number">4.</span> <span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#两阶段锁"><span class="toc-number">4.1.</span> <span class="toc-text">两阶段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">4.2.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行锁模式"><span class="toc-number">4.3.</span> <span class="toc-text">行锁模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行锁的实现"><span class="toc-number">4.4.</span> <span class="toc-text">行锁的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#意向锁"><span class="toc-number">5.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#间隙锁与Next-Key锁"><span class="toc-number">6.</span> <span class="toc-text">间隙锁与Next-Key锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#幻读"><span class="toc-number">6.1.</span> <span class="toc-text">幻读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间隙锁"><span class="toc-number">6.2.</span> <span class="toc-text">间隙锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Next-key-Lock"><span class="toc-number">6.3.</span> <span class="toc-text">Next-key Lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#间隙锁死锁"><span class="toc-number">6.4.</span> <span class="toc-text">间隙锁死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/06/07/oHqT26jk1xnbKJ9.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">奚新灿的博客-Chronos</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">MySQL系列--04锁机制详解</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2020-06-12 12:52:47"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-06-12</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据库锁设计的初衷是处理并发问题。当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁、页级锁和行锁四类。这些锁都属于悲观锁。</p>
<p>MySQL还有一个显著的特点就是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking）；BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁；InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，<strong>InnoDB默认情况下是采用行级锁</strong>。</p>
<p>很难笼统地说哪种锁更好，只能就具体应用场景的特点来说哪种锁更合适。仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</p>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock</code>(FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p><strong>全局锁的典型使用场景是，做全库逻辑备份</strong>。也就是把整库每个表都select出来存成文本。</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<p>你可能会想到一致性视图来解决这个问题从而不锁全库。</p>
<p>其实官方自带的逻辑备份工具mysqldump使用参数<code>–single-transaction</code>导数据，就会启动一个事务来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。<strong>但前提是引擎要支持这个隔离级别</strong>。比如MyISAM就无法支持。所以如果有的表使用了不支持事务的引擎，那么备份就只能通过FTWRL方法。</p>
<p>这时，可能又会有疑问了，既然要全库只读，为什么不使用<code>set global readonly=true</code>的方式呢？</p>
<ol>
<li>在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此不建议使用。</li>
<li>在异常处理机制上有差异。执行FTWRL命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而这种方式则会让数据库一直保持只读方式，风险更高。</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，注意不是表锁。MySQL中的表级锁有两类：<strong>表锁</strong>和<strong>元数据锁</strong>（metadata lock, MDL）。</p>
<h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>表锁的语法是<code>lock tables ... read/write</code>。与FTWRL类似，可以用<code>unlock tables</code>主动释放锁，也会在客户端断开时自动释放。需要注意，lock tables语句除了会限制别的线程的读写外，也会限制本线程接下来的操作对象。</p>
<p>表锁有两种模式：<strong>表共享读锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock）。</p>
<ul>
<li>当一个线程（会话）获得对一张表的写锁后，只有持有锁的线程可以对表进行查询或者更新；其他线程的读写操作都会等待，直到锁被释放为止。</li>
<li>当一个线程（会话）获得对一张表的读锁后，持有读锁的线程可以查询锁定表的记录，但是更新或者访问其他表都会提示错误，即不能查询没有锁定的表；同时，另外一个线程可以查询被锁定表的记录，但是更新就会出现锁等待。</li>
</ul>
<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于InnoDB一般不使用表锁来控制并发，毕竟锁住整个表的影响面还是太大。</p>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</p>
<ul>
<li>MDL读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li>
<li>MDL读写锁之间、MDL写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>
</ul>
<p>同样的，事务中的MDL锁，也是在语句执行开始时申请，语句结束后同样并不会马上释放，而会等到整个事务提交后再释放。</p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>页级锁接触不多，不作阐述，介绍完了全局锁和表级锁，这里重点整理一下InnoDB中默认使用的行锁。MySQL的行锁不是所有的引擎都支持的，使用表锁意味着同一张表上任何时刻只能有一个更新在执行！行锁就是针对数据表中行记录的锁，锁粒度最小。搞清楚行锁，先从两阶段锁说起。</p>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p>先看一个执行流程的例子，假设有一张简单表t，主键id，有数值字段k：</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;<br> update t set k=k+1 where id=1;<br>update t set k=k+1 where id=2;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin;<br> update t set k=k+2 where id=1;</td>
</tr>
<tr>
<td align="center">commit;</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>在上面的执行流程中，事务B的更新语句执行时会出现什么现象呢？结论取决于事务A在执行完两条update语句后，持有哪些锁，以及在什么时候释放。实际上，事务B的更新会被阻塞，直到事务A提交之后才会继续执行。</p>
<p>也就是说，事务A持有的两个记录的行锁，都是在commit之后才释放的。即：<strong>在InnoDB事务中，行锁时在需要的时候才加上的，但并不是不需要了就立即释放，而是等事务结束了才释放</strong>。这就是两阶段锁协议。</p>
<p>从这个协议中能得到一个结论：如果一个事务中需要锁多个行，要把最可能造成锁冲突、最困难影响并发度的锁尽量往后放。这样一旦发生了锁冲突，可以尽可能地减少锁等待时间，提高并发度。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>与表锁不同，行锁的粒度更细，并发度更高，但是是有可能产生死锁的。看一个例子</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;<br> update t set k=k+1 where id=1;</td>
<td align="center">begin;</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update t set k=k+1 where id=2;</td>
</tr>
<tr>
<td align="center">update t set k=k+1 where id=2;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">update t set k=k+1 where id=1;</td>
</tr>
</tbody></table>
<p>例子中事务A等待事务B释放id=2的行锁，而事务B在等待事务A释放id=1的行锁，于是进入死锁状态。当出现死锁之后，有两种策略：</p>
<ul>
<li>等待超时。InnoDB是有超时机制的，可通过参数innodb_lock_wait_timeout设置，默认50s。</li>
<li>发起死锁检测，主动回滚死锁链中的某一个事务。将参数innodb_deadlock_detect设置为on（默认），表示开启这个逻辑。</li>
</ul>
<p>一般正常情况下采用第二个策略，主动检测死锁。因为一旦发生死锁，这种策略能快速发现并进行处理。超时机制默认50s才能退出，也就是说有50s时间无法继续执行，而innodb_lock_wait_timeout值又无法设置一个很小的值，很小的值会带来误伤。</p>
<p>另外，通过<code>SHOW STATUS LIKE &#39;innodb_row_lock%&#39;;</code>可以获取InnoDB行锁的争用情况用作分析。如果发现锁争用比较严重，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。</p>
<h3 id="行锁模式"><a href="#行锁模式" class="headerlink" title="行锁模式"></a>行锁模式</h3><p>InnoDB实现了两种类型的行锁，<strong>共享锁</strong>（读锁、S锁）和<strong>排他锁</strong>（写锁、X锁）。</p>
<ul>
<li><strong>S锁</strong>：允许一个事务去读被加锁的数据集，阻止其他事务获得相同数据集的X锁。如果事务A对数据行i加上S锁，则事务A可以读i，但是不能修改i；其他事务只能再对i加S锁，不能加X锁，直到事务A释放了S锁。也就是保证了其他事务在A释放S锁之前，只能读i，不能修改i。</li>
<li><strong>X锁</strong>：允许获取X锁的事务更新数据，阻止其他事务获取相同数据集的S锁和X锁。如果事务A对数据行加上了X锁，则只有事务A可以读i或者写i，其他事务不能再对i加S锁或者X锁，直到事务A释放。</li>
</ul>
<p>这里对于X锁要注意一点，<strong>排它锁实际上是阻止其他事务不能对已加锁的相同数据集再加锁，但是其他事务里的普通查询是可以的。</strong>因为普通查询不需要锁！这里再次强调一下，select语句默认不会加上任何锁，加X锁用select…for update，加S锁用select…lock in share mode。</p>
<blockquote>
<p>对于UPDATE/DELETE/INSERT语句，InnoDB会自动给涉及数据集加X锁，用SELECT…LOCK IN SHARE MODE获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT… FOR UPDATE方式获得排他锁。</p>
</blockquote>
<h3 id="行锁的实现"><a href="#行锁的实现" class="headerlink" title="行锁的实现"></a>行锁的实现</h3><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应的数据行加锁来实现的。InnoDB这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁</strong>，否则InnoDB将使用表锁！</p>
<p>在实际应用中，需要特别注意InnoDB行锁的这一特点，不然的话会导致大量的锁冲突从而影响并发性能。</p>
<ul>
<li>在不通过索引条件查询的时候，InnoDB无法使用行锁，只能使用表锁。</li>
<li>由于InnoDB的行锁是针对索引添加，所以当访问不同的行记录，但是使用的是相同的索引键时，是会出现锁冲突的。</li>
<li>当有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行。</li>
<li>不论是使用主键索引、唯一索引还是普通索引，InnoDB都会使用行锁来对数据加锁。</li>
<li>及时在条件中使用了索引字段，但是是否使用索引键锁数据是由MySQL通过不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，那就不会使用索引。这种情况下InnoDB也会使用表锁。因此在检查锁冲突的时候，别忘了检查SQL执行计划。</li>
</ul>
<h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>InnoDB为了允许表锁和行锁共存，实现多粒度锁机制，内部还使用了一种<strong>表级锁</strong>–<strong>意向锁</strong>（Intension Lock），意向锁也有两种：</p>
<ul>
<li>意向共享锁（IS锁）：事务打算给数据行加共享锁，事务在给一个数据行加S锁之前必须先获得该表的IS锁。</li>
<li>意向排他锁（IX锁）：事务打算给数据行加排他锁，事务在给一个数据行加X锁之前必须先获得改表的IX锁。</li>
</ul>
<p>InnoDB行锁与意向锁兼容性一览表：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">X</th>
<th align="center">IX</th>
<th align="center">S</th>
<th align="center">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center"><strong>冲突</strong></td>
<td align="center"><strong>冲突</strong></td>
<td align="center"><strong>冲突</strong></td>
<td align="center"><strong>冲突</strong></td>
</tr>
<tr>
<td align="center">IX</td>
<td align="center"><strong>冲突</strong></td>
<td align="center">兼容</td>
<td align="center"><strong>冲突</strong></td>
<td align="center"><strong>冲突</strong></td>
</tr>
<tr>
<td align="center">S</td>
<td align="center"><strong>冲突</strong></td>
<td align="center"><strong>冲突</strong></td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
<tr>
<td align="center">IS</td>
<td align="center"><strong>冲突</strong></td>
<td align="center">兼容</td>
<td align="center">兼容</td>
<td align="center">兼容</td>
</tr>
</tbody></table>
<p>如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。</p>
<p><strong>意向锁是InnoDB自动加的，不需要用户干预。</strong></p>
<h2 id="间隙锁与Next-Key锁"><a href="#间隙锁与Next-Key锁" class="headerlink" title="间隙锁与Next-Key锁"></a>间隙锁与Next-Key锁</h2><p>这两种锁的引入其实是为了解决幻读问题，那么我们先从幻读问题开始看起。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。这里，需要对“幻读”做一个说明：</p>
<ul>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。</li>
<li>幻读仅专指“新插入的行”。</li>
</ul>
<p>为了说明幻读问题，我们还是用一个例子来说明，假设又一张表t，初始化如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>假设有三个事务，执行流程如下所示：</p>
<table>
<thead>
<tr>
<th align="center">时刻</th>
<th align="center">事务A</th>
<th align="center">事务B</th>
<th align="center">事务C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T1</td>
<td align="center">begin;<br>select * from t where d=5 for update;//Q1<br>update t set d=100 where d=5;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T2</td>
<td align="center"></td>
<td align="center">update t set d=5 where id=0;<br>update t set c=5 where id=0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T3</td>
<td align="center">select * from t where d=5 for update;//Q2</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">insert into t values(1,1,5);<br>update t set c=5 where id=1;</td>
</tr>
<tr>
<td align="center">T5</td>
<td align="center">select * from t where d=5 for update;//Q3</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">T6</td>
<td align="center">commit;</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>T1时刻，事务A先执行查询，是一个当前读，加X锁，并且d字段没有索引，因此会锁住t表所有的行，所以事务B执行第一个update语句会被锁住，需要等到T6时刻事务A提交以后才能继续执行。这样对于id=0这一行，在数据库里最终结果还是(0,5,5)。根据我们已经介绍的锁的知识，目前得出在binlog里，执行序列是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>);    //(1,1,5)</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;    //(1,5,5)</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;   //所有d=5的行，d改成100</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>;    //(0,0,5)</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>;    //(0,5,5)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么事务C的T4时刻日志在最前面？不清楚的可以回顾一下MySQL系列第2篇日志系统相关知识。</p>
</blockquote>
<p>可以看到，按照日志顺序，id=0这一行的最终结果是(0,5,5)，这没有什么问题，问题是id=1这一行的数据最终是多少呢？根据binlog执行顺序可以得出，id=1这一行最终是(1,5,100)。T3时刻给所有的行加锁时，id=1的行还不存在，不存在也就加不上锁，也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这就是幻读。而实际上，如果你在数据库中模拟执行的话，你会发现id=1这一行最终是(1,5,5)。换句话说InnoDB实际上还是在T4时刻阻止了事务C新插入记录的操作，解决了幻读问题，否则id=1这一行查询出的结果将会和以上分析的结果一致为(1,5,100)。那InnoDB是怎么解决幻读的呢？</p>
<blockquote>
<p>上面的binlog执行序列根据之前已经介绍过的锁的知识得出，但是很可惜，它仍旧是错误的（可重复读隔离级别下），因为还缺少了接下来的知识点–间隙锁，而间隙锁的引入正是InnoDB解决幻读的重要环节。</p>
</blockquote>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>现在我们知道了，产生幻读的原因是行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读InnoDB只好引入新的锁，也就是间隙锁（Gap Lock）。顾名思义，间隙锁，锁的就是两个行之间的间隙，比如本节的表t初始化插入了6条记录，这就产生了7个间隙。</p>
<p>这样，当事务A在T1时刻执行<code>select * from t where d=5 for update</code>的时候，就不知给数据库中已有的6条记录加上了锁，同时还加了7个间隙锁，以此确保无法插入新的记录，因此在事务A提交事务释放锁之前，事务C在T4时刻的插入实际上是被阻塞了的。事务B和C都是在事务A提交之后才会继续执行！</p>
<p>至此得出的结论：数据行可以加上锁的实体，数据行之间的间隙也可以加上锁的实体。</p>
<p>但是<strong>间隙锁跟我们之前讲过的锁都不不太一样</strong>。比如行锁，无论是行锁的读锁或写锁，跟它有冲突关系的是“另外一个锁”。但是<strong>跟间隙锁存在冲突关系的，是往被锁住的这个间隙中插入一条记录操作</strong>。间隙锁之间是不存在冲突关系的。为了更好的理解，再用表t举个例子，看下面的执行流程：</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;<br>select * from t where c=7 lock in share mode;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin;<br>select * from t where c=7 for update;</td>
</tr>
</tbody></table>
<p>这里的事务B并不会被阻塞。表t中没有c=7的行，事务A加的间隙锁(5,10)区间，同样事务B加的间隙锁也是(5,10)区间。他们有共同的目标：保护这个间隙，不允许插入值。因此他们是不冲突的。</p>
<h3 id="Next-key-Lock"><a href="#Next-key-Lock" class="headerlink" title="Next-key Lock"></a>Next-key Lock</h3><p>间隙锁和行锁合称为next-key lock，每个next-key lock为前开后闭的区间。在表t中，如果用<code>select * from t for update;</code>要把整个表所有记录锁起来，就形成了7个next-key lock，分别是(-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]</p>
<blockquote>
<p>为什么是+supremum而不是+∞？因为next-key lock是一个前开后闭区间，而+∞是一个开区间，所以在实现上，InnoDB给每个索引加了一个不存在的最大值suprenum（不是supernum）来满足next-key lock“后闭”的条件。</p>
</blockquote>
<p>因此，也可以说<strong>间隙锁合next-key lock的引入，解决了幻读的问题</strong>。</p>
<h3 id="间隙锁死锁"><a href="#间隙锁死锁" class="headerlink" title="间隙锁死锁"></a>间隙锁死锁</h3><p>看一个因间隙锁形成死锁的例子，同样适用初始化后的表t：</p>
<table>
<thead>
<tr>
<th align="center">事务A</th>
<th align="center">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;<br>select * from t where id=9 for update;</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">begin;<br>select * from t where id=9 for update;</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">insert into t values(9,9,9);<br>[<em>blocked</em>]</td>
</tr>
<tr>
<td align="center">insert into t values(9,9,9);<br>[<em>ERROR:Deadlock found!</em>]</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>事务A实行当前读，由于id=9行不存在，因此加上间隙锁(5,10)</li>
<li>事务B执行当前读，同样加上间隙锁(5,10)</li>
<li>事务B尝试插入，与事务A的间隙锁冲突，进入等待</li>
<li>事务A尝试插入，与事务B的间隙锁冲突，进入等待</li>
<li>至此，两个事务互相等待，形成死锁。然后InnoDB死锁检测马上发现了这对死锁关系，让事务A的插入语句报错返回了。</li>
</ol>
<p>至此间隙锁内容整理完了，最后补充一点，<strong>间隙锁是在可重复读隔离级别下才会生效的</strong>。所以，如果把隔离级别设置为读提交的话，就没有间隙锁了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于全局锁</p>
<ul>
<li>典型应用场景–全局逻辑备份</li>
<li>FTWRL比set global readonly=true更适合做全库只读备份</li>
</ul>
<p>关于表级锁</p>
<ul>
<li>表级锁有表锁合MDL两类，表锁的锁定粒度大</li>
<li>表锁共享读锁（S）之间是兼容的，但共享读锁（S）与排他写锁（X）之间，以及排他写锁（X）之间是互斥的，也就是说读和写是串行的</li>
<li>MyISAM使用表锁，在一定条件下，MyISAM允许查询和插入并发执行，拓展：MyISAM默认的锁调度机制是写优先</li>
<li>意向锁也是一种表级锁，InnoDB中使用，不需要用户干预</li>
</ul>
<p>关于行锁</p>
<ul>
<li>InnoDB默认使用行锁，行锁粒度小，并发度高同时锁冲突的几率也高，会形成死锁</li>
<li>分S锁和X锁，读写串行，与意向锁一起使用实现多粒度锁机制</li>
<li>锁在有需要时才添加，事务提交之后才释放 – 两阶段锁概念</li>
<li>InnoDB的行锁是基于索引实现的，如果不通过索引访问数据，InnoDB会将扫描到的行都加锁</li>
<li>可重复读级别下，引入间隙锁解决幻读，间隙锁和行锁合称next-key lock</li>
<li>间隙锁不同于其他锁，与之冲突的是往间隙中插入数据的这个操作，它也会导致死锁</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:xixincan@163.com">奚新灿</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/xixincan/xixincan.github.io/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/">https://github.com/xixincan/xixincan.github.io/2020/06/12/MySQL/MySQL%E7%B3%BB%E5%88%97-04%E9%94%81%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/xixincan/xixincan.github.io" target="_blank">奚新灿的博客-Chronos</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SQL/">SQL</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/MySQL%E7%B3%BB%E5%88%97/">MySQL系列</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/08/20/64HlxeIsjnfFDym.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpeg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpeg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/06/16/MySQL/MySQL%E7%B3%BB%E5%88%97-05%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"><img class="prev_cover" src="https://i.loli.net/2020/06/07/UIlfGEs8iLVrhc4.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL系列--05索引详解</div></div></a></div><div class="next-post pull_right"><a href="/2020/06/09/MySQL/MySQL%E7%B3%BB%E5%88%97-03%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"><img class="next_cover" src="https://i.loli.net/2020/06/07/X4Hy3FGuwRrPTMa.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL系列--03事务及隔离级别</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/06/06/MySQL/MySQL系列-01查询语句的执行/" title="MySQL系列--01查询语句的执行"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/oYP4lZqSCrI87Od.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-06</div><div class="relatedPosts_title">MySQL系列--01查询语句的执行</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/07/MySQL/MySQL系列-02更新语句的执行/" title="MySQL系列--02更新语句的执行"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/Onkho7mDQaN4Lw3.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-07</div><div class="relatedPosts_title">MySQL系列--02更新语句的执行</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/09/MySQL/MySQL系列-03事务及隔离级别/" title="MySQL系列--03事务及隔离级别"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/X4Hy3FGuwRrPTMa.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-09</div><div class="relatedPosts_title">MySQL系列--03事务及隔离级别</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/16/MySQL/MySQL系列-05索引详解/" title="MySQL系列--05索引详解"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/UIlfGEs8iLVrhc4.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-16</div><div class="relatedPosts_title">MySQL系列--05索引详解</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/19/MySQL/MySQL系列-06MySQL会选错索引？/" title="MySQL系列--06MySQL会选错索引？"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/IJ6yCUvja8g9z7P.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-19</div><div class="relatedPosts_title">MySQL系列--06MySQL会选错索引？</div></div></a></div><div class="relatedPosts_item"><a href="/2020/06/24/MySQL/MySQL系列-07Explain详解/" title="MySQL系列--07Explain详解"><img class="relatedPosts_cover" src="https://i.loli.net/2020/06/07/2quU1hGkY5QwHJt.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-06-24</div><div class="relatedPosts_title">MySQL系列--07Explain详解</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick/mail/link')
var requiredFields = requestSetting(['nick','mail','link'],'nick')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'jEPAIPxYjthHjPu5b3KdB6VB-gzGzoHsz',
  appKey: 't7yb02rahA7PQDMrFvmfjs1E',
  notify: false,
  verify: false,
  placeholder: '留下点什么...',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true //,
  //requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 奚新灿</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, 欢迎来到<a href='https://xixincan.github.io' target="_blank" rel="noopener">Chronos</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>